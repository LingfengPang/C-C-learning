# 数学题
## Boyer-Moore 投票算法
### 169. 多数元素
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
```
## 其他
### 7.整数翻转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
```cpp
//O(logn) o(1)
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while(x!=0){
            //这题的难点在于处理数据越界！！！
            if (res < INT_MIN / 10 || res > INT_MAX / 10) {
                return 0;
            }
            int mod = x%10;
            x /= 10;
            res = res*10 + mod;
        }
        return res;
    }
};
```

### 9.回文数
判断这个数字是不是回文
![回文数](image/9.png)
```cpp
//O(logN) O(1)
class Solution {
public:
    bool isPalindrome(int x) {
        if(x < 0 || (x%10 == 0 && x != 0))
            return false;//负数肯定不是
        int mod = 0;
        while(mod < x){
            mod = mod*10 +x%10;
            x /= 10;  
        }

        if(x == mod || (mod/10) == x)
            return true;
        return false;
    }
};
```
### 13.罗马数字
把罗马数字转化为数字
```cpp
class Solution {
public:
    int romanToInt(string s) {
        map<char,int> roman = {
            {'I',1},
            {'V',5},
            {'X',10},
            {'L',50},
            {'C',100},
            {'D',500},
            {'M',1000},
        };
        int num = 0;
        int len = s.length();
        num += roman[s[len-1]];
        for(int i = len-2;i>=0;i--){
            if(roman[s[i+1]]>roman[s[i]]){
                num -=  roman[s[i]];
            }
            else
                num += roman[s[i]];
        }


        return num;
    }
};
```


### 49.图像旋转
将一个二维数组逆时针旋转90°
思路看49题解吧
1.原地旋转
```cpp
//O（N*N） O（1）
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int size = matrix.size();
        for(int i = 0;i<size/2;i++){//有几圈
            for(int j = 0;j<(size+1)/2;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[size-1-j][i];
                matrix[size-1-j][i] = matrix[size-1-i][size-1-j];
                matrix[size-1-i][size-1-j] = matrix[j][size-1-i];
                matrix[j][size-1-i] = temp;
            }
        }
    }
};
```
2.原地翻转
```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int size = matrix.size();
        //水平翻转
        for(int i = 0;i<size;i++){
            for(int j = 0;j<size/2;j++){
                swap(matrix[j][i],matrix[size-j-1][i]);
            }
        }
        //对角线翻转
        for(int i = 0;i<size;i++){
            for(int j = 0;j<i;j++){
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
};
```
### 50.Pow(x, n)
思路：例如x的11的幂可以如下递归 11 - 5 - 4 - 2 - 1 - 0 

1.快速幂加递归
```cpp
//logN 1
class Solution {
public:
    double qmul(double x,long long N){
        if(N == 0)
            return 1.0;
        double y = qmul(x,N/2);//11 5 2 1 0
        return (N%2 == 0?y*y:x*y*y);
    }
    double myPow(double x, int n) {
        long long N = n;
        return (N>=0?qmul(x,N):1/qmul(x,-N)); 
    }
};
```
2.当然也能用迭代
```cpp
//logN 1
class Solution {
public:
    double quickMul(double x, long long N) {
        double ans = 1.0;
        // 贡献的初始值为 x
        double x_contribute = x;
        // 在对 N 进行二进制拆分的同时计算答案
        while (N > 0) {
            if (N % 2 == 1) {
                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
                ans *= x_contribute;
            }
            // 将贡献不断地平方
            x_contribute *= x_contribute;
            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
            N /= 2;
        }
        return ans;
    }

    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};

```


### 66. 加一
```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```
```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int add = 0;//进位


        for(auto it = digits.rbegin();it!= digits.rend();it++){
            if(it == digits.rbegin()){
                *it = (*it)+1;
                add = (*it)/10;
                *it = (*it)%10;
            }
            else{
                if(add){
                    *it = (*it)+1;
                    add = (*it)/10; 
                    *it = (*it)%10;
                }
                else
                    break;

            }
        }

        if(add){
            digits.insert(digits.begin(),1);
        }

        return digits;
    }
};
```
### 69.x 的平方根
1.数学法
$\sqrt x = x^{0.5} = e^{lnx^{0.5}} = e^{0.5lnx} $


```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        int ans = exp(0.5 * log(x));
        return ((long long)(ans + 1) * (ans + 1) <= x ? ans + 1 : ans);//由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 IEEE 754，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。
    }
};
/**
作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
**/
```

2.牛顿迭代法
```
这题的解法用暴力解法是非常简单的。主要的麻烦在于如何解的更好，答案就是用牛顿迭代法。

下面这种方法可以很有效地求出根号 a 的近似值：首先随便猜一个近似值 x，然后不断令 x 等于 x 和 a/x 的平均数，迭代个六七次后 x 的值就已经相当精确了。

例如，我想求根号 2 等于多少。假如我猜测的结果为 4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：
( 4 + 2/ 4 ) / 2 = 2.25
( 2.25 + 2/ 2.25 ) / 2 = 1.56944..
( 1.56944..+ 2/1.56944..) / 2 = 1.42189..
( 1.42189..+ 2/1.42189..) / 2 = 1.41423..
作者：LOAFER
链接：https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }
        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```
### 118.杨辉三角
给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
![杨辉三角](image/118.gif)
在杨辉三角中，每个数是它左上方和右上方的数的和。
```cpp
//O(n*n),o(1)
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> tri;
        for(int i = 0;i<numRows;i++){
            vector<int> row;
            for(int j=0;j<=i;j++){
                if((i <= 1)||(j == 0)||(j == i))
                    row.push_back(1);
                else{
                    row.push_back(tri[i-1][j]+tri[i-1][j-1]);
                }
            }
            tri.push_back(row);
        }
        return tri;
    }
};
```
### 166. 分数到小数
给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 10^4 。
```
输入：numerator = 1, denominator = 2
输出："0.5"

输入：numerator = 2, denominator = 3
输出："0.(6)"
```
思路：长除法
```cpp
class Solution {
public:
    //小数部分如果余数重复出现两次就表示该小数是循环小数了
    string fractionToDecimal(int numerator, int denominator) {
        if(denominator==0) return "";//边界条件，分母为0
        if(numerator==0) return "0";//边界条件，分子为0
        string result;
        
        //转换为longlong防止溢出
        long long num = static_cast<long long>(numerator);
        long long denom = static_cast<long long>(denominator);
        
        //处理正负号，一正一负取负号
        if((num>0)^(denom>0))result.push_back('-');
        
        //分子分母全部转换为正数
        num=llabs(num);denom=llabs(denom);
        
        //处理整数部分
        result.append(to_string(num/denom));
        
        //处理小数部分
        num%=denom;                         //获得余数
        if(num==0)return result;             //余数为0，表示整除了，直接返回结果
        result.push_back('.');              //余数不为0，添加小数点
        int index=result.size()-1;          //获得小数点的下标
        unordered_map<int,int> record;      //map用来记录出现重复数的下标，然后将'('插入到重复数前面就好了
        while(num&&record.count(num)==0){   //小数部分：余数不为0且余数还没有出现重复数字
            record[num]=++index;
            num*=10;                        //余数扩大10倍，然后求商，和草稿本上运算方法是一样的
            result+=to_string(num/denom);
            num%=denom;
        }
        if(record.count(num)==1){           //出现循环余数，我们直接在重复数字前面添加'(',字符串末尾添加')'
            result.insert(record[num],"(");
            result.push_back(')');
        }
        return result;
    }
};
```

### 168. Excel表列名称
给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```
```cpp
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string ans;
        while (columnNumber > 0) {
            --columnNumber;
            ans += columnNumber % 26 + 'A';
            columnNumber /= 26;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```
### 171. Excel表列序号
给定一个Excel表格中的列名称，返回其相应的列序号。
```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```
思路：就是当成26进制啦
难点：有个内存溢出要处理一下啦
```cpp
class Solution {
public:
    int titleToNumber(string columnTitle) {
        int num = 0;
        int ans = 0;
        for(char c:columnTitle){
            ans =  c-'A'+1;//先减A防止内存溢出
            num = num*26 + ans;
        }
        return num;
    }
};
```
### 172. 阶乘后的零
给定一个整数 n，返回 n! 结果尾数中零的数量。
```
思路
产生末尾0的是2*5的因子，而且阶乘中2的因子肯定比5的多，所以任意一个5的因子都能匹配一个2的因子，那么题目就是计算5的因子个数了
```

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        int sum = 0;
        while(n > 0){
            n /= 5;
            sum += n;
        }
        return sum;
    }
    
};
```


### 204.计算质数
1.枚举法（leetcode超时）
```cpp
//O(n sqrt(n) ) O(1)
class Solution {
public:
    int countPrimes(int n) {
        int num = 0;
        bool none = 0;
        if(n>2){
            for(int i = 2;i<n;i++){
                int k=(int)sqrt((double)i);
                for(int j = 2;j<=k;j++){
                    if(i%j == 0){
                        none = 1;
                        break;
                    }
                }

                if(!none){
                    num++;
                }
                none = 0;
            }
        }       
        return num;
    }
};
```

2.埃氏筛
```cpp
class Solution {
public:
    int countPrimes(int n) {
        vector<int> isPrime(n, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ans += 1;
                if ((long long)i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
};


```
3.线性筛
```cpp
class Solution {
public:
    int countPrimes(int n) {
        vector<int> pirme;
        vector<int> isprime(n,true);

        for(int i = 2;i<n;i++){
            if(isprime[i]){
                pirme.push_back(i);
            }
            for(int j = 0;j<pirme.size()&&i*pirme[j]<n;j++)
                isprime[i*pirme[j]] = false;
            
        }
        return pirme.size();
    }
};
```
### 268. 丢失的数字
给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。其中数组中每个数字都是独一无二的

思路：高斯求和公式
```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int sum1 = 0;
        int sum2 = (0+nums.size())*(nums.size()+1)/2;
        for(int num : nums){
            sum1 += num;
        }
        return (sum2-sum1);
    }
};
```
### 326. 3的幂
判断是不是3的幂

循环迭代法
O(logn) O(1)
```cpp
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n<1)
            return false;

        int num = n;
        while(num %3 == 0){
            num /= 3;
        }
        return num== 1;
    }    
};
```

### 342.4的幂
思路
(4)^x = (3+1)^x
那么4的幂 对3取余 得1 
```cpp
class Solution {
public:
    bool isPowerOfFour(int n) {
         return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1;
    }
};
```


### 621. 任务调度器
给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。

然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 最短时间 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/task-scheduler
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

思路：看官解
```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        unordered_map<char, int> freq;
        //存表
        for (char ch: tasks) {
            ++freq[ch];
        }
        
        // 任务总数
        int m = freq.size();

        vector<int> nextValid, rest;
        //取值
        for (auto [_, v]: freq) {
            nextValid.push_back(1);//下一次可执行时间
            rest.push_back(v);//剩余次数
        }

        int time = 0;
        for (int i = 0; i < tasks.size(); ++i) {
            time++;
            int nextValidMin = INT_MAX;
            for(int i = 0;i<m;i++){
                if(rest[i])//判断最快的时间
                    nextValidMin = min(nextValid[i],nextValidMin);
            }
            time = max(time,nextValidMin);
            int best = -1;//次数最多的下标            
            for(int i = 0;i<m;i++){
                if (rest[i] && nextValid[i] <= time)
                    if(best == -1 || rest[i]>rest[best]){
                        best = i;
                    }
            }
            nextValid[best] = time+n+1;
            rest[best]--; 
        }

        return time;
    }
};
```

2.桶思想
[桶思想](https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/)
```cpp
class Solution {
public:
int leastInterval(vector<char>& tasks, int n) {
        int len=tasks.size();
        vector<int> vec(26);
        for(char c:tasks) 
            ++vec[c-'A'];
        sort(vec.rbegin(),vec.rend());
        int cnt = 1;
        while(cnt < vec.size()&&vec[cnt] == vec[0])
            cnt++;
        return max(len,cnt+(vec[0]-1)*(n+1));
    }
};
```