# 图
## 深度优先搜索DFS
### 417. 太平洋大西洋水流问题
```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& heights,vector<vector<bool>>& reach,int i,int j){
        if( reach[i][j])
            return;//必须加这句，否则内存爆炸，
        reach[i][j] = true;
        int row = heights.size();
        int col = heights[0].size();
        if(i-1>=0 && heights[i][j]<=heights[i-1][j]) dfs(heights,reach,i-1,j);
        if(i+1<row&& heights[i][j]<=heights[i+1][j]) dfs(heights,reach,i+1,j);
        if(j-1>=0 && heights[i][j]<=heights[i][j-1]) dfs(heights,reach,i,j-1);
        if(j+1<col&& heights[i][j]<=heights[i][j+1]) dfs(heights,reach,i,j+1);
        
    }
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        vector<vector<int>> res;
        
        
        int row = heights.size();
        int col;
        if(row == 0)
          return res;
        col = heights[0].size();

        vector<vector<bool>> reach_pac(row,vector<bool>(col,false));
        vector<vector<bool>> reach_atl(row,vector<bool>(col,false));

        for(int i = 0;i<col;i++){
            dfs(heights,reach_pac,0,i);
            dfs(heights,reach_atl,row-1,i);
        }
        for(int i = 0;i<row;i++){
            dfs(heights,reach_pac,i,0);
            dfs(heights,reach_atl,i,col-1);
        }




        for(int i = 0;i<row;i++){
            for(int j = 0;j<col;j++){
                if(reach_pac[i][j]&&reach_atl[i][j])
                    res.push_back(vector<int>{i,j});
            }
        }
        return res;
    }
};
```
### 547. 省份数量
给了一个邻接矩阵

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& isConnected,vector<bool>& visited,int k){
        visited[k] = true;
        for(int i = 0;i<isConnected.size();i++){
            if(isConnected[k][i] && !visited[i])
                dfs(isConnected,visited,i);
        }
    }
    int findCircleNum(vector<vector<int>>& isConnected) {
        int city = isConnected.size();
        int res = 0;
        vector<bool> visited(city,false);
        for(int i = 0;i<city;i++){
            if(!visited[i]){
                res++;
                dfs(isConnected,visited,i);
            }
        }
        return res;
    }
};
```
### 695. 岛屿的最大面积
```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& grid,int row,int col,int &S){
        // if(0 == grid[row][col])
        //     return;
        grid[row][col] = 0;
        S++;
        if(row-1>=0 && 1==grid[row-1][col])  dfs(grid,row-1,col,S);
        if(row+1<grid.size()&& 1==grid[row+1][col])  dfs(grid,row+1,col,S);
        if(col-1>=0&& 1==grid[row][col-1])  dfs(grid,row,col-1,S);
        if(col+1<grid[0].size()&& 1==grid[row][col+1])  dfs(grid,row,col+1,S);

    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int maxS = 0;
        int S = 0;
        int row = grid.size();
        if(0 == row)
            return 0;
        int col = grid[0].size();
        for(int i = 0;i<row;i++){
            for(int j = 0;j<col;j++){
                if(grid[i][j])
                    dfs(grid,i,j,S);
                if(S>maxS)
                    maxS = S;
                S = 0;
                }
        }
        return maxS;
    }
};
```

## BFS 广度优先
### 126. 单词接龙 II
按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：

每对相邻的单词之间仅有单个字母不同。
转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。
sk == endWord
给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/word-ladder-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


```cpp
class Solution {
public:
    void back(const string &src,const string &dst,unordered_map<string,vector<string>> &next,vector<string> &path,vector<vector<string>> &res){
        if(src == dst){
            res.push_back(path);
            return;
        }
        for(const auto &s:next[src]){
            path.push_back(s);
            back(s,dst,next,path,res);
            path.pop_back();
        }
    }
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        vector<vector<string>> res;
        unordered_set<string> dict;
        for(const auto &w:wordList){
            dict.insert(w);
        }
        if(!dict.count(endWord))
            return res;
        
        dict.erase(beginWord);
        dict.erase(endWord);

        unordered_set<string> q1{beginWord},q2{endWord};
        unordered_map<string,vector<string>> next;
        bool reversed = false;
        bool found = false;

        while(!q1.empty()){
            unordered_set<string> q;
            for(const auto &w:q1){
                string s = w;
                for(size_t i = 0;i<s.size();i++){
                    char ch = s[i];
                    for(int j = 0;j<26;j++){
                        s[i] = j + 'a';//依次改变
                        if(q2.count(s)){
                            reversed?next[s].push_back(w):next[w].push_back(s);
                            found = true;
                        }
                        if(dict.count(s)){
                            reversed?next[s].push_back(w):next[w].push_back(s);
                            q.insert(s);
                        }
                    }
                    s[i] = ch;
                }
            }
            if(found){
                break;
            }
            for(const auto &w:q){
                dict.erase(w);//把保存的给删了，防止循环
            }
            if(q.size() <= q2.size()){
                q1 = q;
            }
            else{//翻转，头和尾BFS，减少搜索次数
                reversed =! reversed;
                q1 = q2;
                q2 = q;
            }
        }
        if(found){
            vector<string> path = {beginWord};
            back(beginWord,endWord,next,path,res);//回溯，感觉有点像广度优先遍历
        }
        return res;
    }
};
```
### 934. 最短的桥
在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）

现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。

返回必须翻转的 0 的最小数目。（可以保证答案至少是 1 。）

```cpp
class Solution {
public:
    
    void dfs(queue <pair<int,int>> &points,vector<vector<int>>& grid,int m,int n,int i,int j){
        if(i<0||j<0||i>=m||j>=n||grid[i][j] == 2)
            return;
        if(grid[i][j] == 0){
            points.push({i,j});
            return;
        }
        grid[i][j] = 2;
        dfs(points,grid,m,n,i-1,j);
        dfs(points,grid,m,n,i+1,j);
        dfs(points,grid,m,n,i,j-1);
        dfs(points,grid,m,n,i,j+1);
    }
    int shortestBridge(vector<vector<int>>& grid) {
        int direction[5] = {-1,0,1,0,-1};
        //利用dfs找到第一个岛屿
        int m = grid.size();
        int n = grid[0].size();
        queue <pair<int,int>> points;
        bool first = false;
        for(int i = 0;i<m;i++){
            if(first) break;
            for(int j = 0;j<n;j++){
                if(grid[i][j] == 1){
                    dfs(points,grid,m,n,i,j);
                    first = true;
                    break;
                }
            }
        }

        //bfs寻找第二个岛屿
        int x,y;
        int level = 0;
        while(!points.empty()){
            ++level;
            int n_points = points.size();
            
            while(n_points--){
                auto [r,c] = points.front();
                points.pop();
                for(int k = 0;k<4;++k){
                    x = r+direction[k] ;
                    y = c+direction[k+1];
                    if(x>=0&&y>=0&&x<m&&y<n){//把周围铺上为2
                        if(grid[x][y] == 2)
                            continue;
                        if(grid[x][y] == 1)
                            return level;
                        points.push({x,y});
                        grid[x][y] = 2;
                    }
                }
            }
        }
        return 0;
    }
};
```

