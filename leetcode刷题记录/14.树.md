### 98. 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。


- 1.递归
O（n） O(n)
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```
- 2 中序遍历
//中序遍历的结果应该是一个升序就正确
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) {
                return false;
            }
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }
};
```

### 101. 对称二叉树
1. 递归
```cpp
class Solution {
public:
    bool check(TreeNode *p,TreeNode *q){
        if(!p&&!q) return true;
        else if(!p||!q) return false;
        return (p->val == q->val)&&check(p->left,q->right)&&check(p->right,q->left);
    }
    bool isSymmetric(TreeNode* root) {
        return check(root,root);
    }
};
```
- 2迭代
学会用队列替代递归
```cpp
class Solution {
public:
    bool check(TreeNode *p,TreeNode *q){
        queue<TreeNode*> Q;
        Q.push(p);
        Q.push(q);
        while(!Q.empty()){
            p = Q.front();
            Q.pop();
            q = Q.front();
            Q.pop();
            if(!p&&!q) continue;
            else if(!p||!q) return false;
            else if(p->val != q->val) return false;
            Q.push(p->left);
            Q.push(q->right);
            Q.push(p->right);
            Q.push(q->left);
        }
        return true;
    }
    bool isSymmetric(TreeNode* root) {
        return check(root,root);
    }
};
```
### 102. 二叉树的层序遍历
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root)
            return res;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            int level = q.size();
            vector<int> lres;
            for(int i = 0;i<level;i++){
                TreeNode *t = q.front();
                q.pop();
                if(t){
                    lres.push_back(t->val);
                    q.push(t->left);
                    q.push(t->right);
                }
            }
            if(lres.size())
                res.push_back(lres);
        }
        return res;
    }
};
```
### 103. 二叉树的锯齿形层序遍历
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode *> q;
        if(!root)
            return res;
        q.push(root);
        int l = 0;
        while(!q.empty()){
            int level = q.size();
            vector<int> lres;
            for(int i = 0;i<level;i++){
                TreeNode *t = q.front();
                q.pop();
                if(t){
                    if(l%2 == 0){
                        lres.push_back(t->val);
                    }
                    else{
                        lres.insert(lres.begin(),t->val);
                    }
                    q.push(t->left);
                    q.push(t->right);
                }
            }
            l++;
            if(lres.size())
                res.push_back(lres);
        }
        return res;
    }
};
```
### 104. 二叉树的最大深度
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};

```


### 671. 二叉树中第二小的节点
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

思路：DFS
```cpp
//O（n） O(n)
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        return min2nd(root, root -> val);
    }

    int min2nd(TreeNode* root, int val) {
        // 根节点为空
        if(!root)
            return -1;
        if(root->val>val)
            return root->val;
        int leftMin = min2nd(root->left,val);//寻找左边比根大的
        int rightMin = min2nd(root->right,val);//寻找右边比根大的
        if(leftMin>0&&rightMin>0)
            return min(leftMin,rightMin);
        return max(leftMin,rightMin); 
    }      
};

```