### 98. 验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。


- 1.递归
O（n） O(n)
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) {
            return true;
        }
        if (root -> val <= lower || root -> val >= upper) {
            return false;
        }
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```
- 2 中序遍历
//中序遍历的结果应该是一个升序就正确
```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) {
                return false;
            }
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }
};
```

### 101. 对称二叉树
1. 递归
```cpp
class Solution {
public:
    bool check(TreeNode *p,TreeNode *q){
        if(!p&&!q) return true;
        else if(!p||!q) return false;
        return (p->val == q->val)&&check(p->left,q->right)&&check(p->right,q->left);
    }
    bool isSymmetric(TreeNode* root) {
        return check(root,root);
    }
};
```
- 2迭代
学会用队列替代递归
```cpp
class Solution {
public:
    bool check(TreeNode *p,TreeNode *q){
        queue<TreeNode*> Q;
        Q.push(p);
        Q.push(q);
        while(!Q.empty()){
            p = Q.front();
            Q.pop();
            q = Q.front();
            Q.pop();
            if(!p&&!q) continue;
            else if(!p||!q) return false;
            else if(p->val != q->val) return false;
            Q.push(p->left);
            Q.push(q->right);
            Q.push(p->right);
            Q.push(q->left);
        }
        return true;
    }
    bool isSymmetric(TreeNode* root) {
        return check(root,root);
    }
};
```
### 102. 二叉树的层序遍历
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root)
            return res;
        queue<TreeNode *> q;
        q.push(root);
        while(!q.empty()){
            int level = q.size();
            vector<int> lres;
            for(int i = 0;i<level;i++){
                TreeNode *t = q.front();
                q.pop();
                if(t){
                    lres.push_back(t->val);
                    q.push(t->left);
                    q.push(t->right);
                }
            }
            if(lres.size())
                res.push_back(lres);
        }
        return res;
    }
};
```
### 103. 二叉树的锯齿形层序遍历
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode *> q;
        if(!root)
            return res;
        q.push(root);
        int l = 0;
        while(!q.empty()){
            int level = q.size();
            vector<int> lres;
            for(int i = 0;i<level;i++){
                TreeNode *t = q.front();
                q.pop();
                if(t){
                    if(l%2 == 0){
                        lres.push_back(t->val);
                    }
                    else{
                        lres.insert(lres.begin(),t->val);
                    }
                    q.push(t->left);
                    q.push(t->right);
                }
            }
            l++;
            if(lres.size())
                res.push_back(lres);
        }
        return res;
    }
};
```
### 104. 二叉树的最大深度
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};

```
### 105. 从前序与中序遍历序列构造二叉树
1.递归
```cpp
class Solution {
private:
    unordered_map<int, int> index;

public:
    TreeNode* myBuildTree(const vector<int>& preorder, const vector<int>& inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return nullptr;
        }
        
        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = index[preorder[preorder_root]];
        
        // 先把根节点建立出来
        TreeNode* root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root->left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root->right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        // 构造哈希映射，帮助我们快速定位根节点
        for (int i = 0; i < n; ++i) {
            index[inorder[i]] = i;
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
2.迭代
用栈的方式
```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (!preorder.size()) {
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[0]);
        stack<TreeNode*> stk;
        int inorderIndex = 0;
        stk.push(root);
        for(int i = 1;i<preorder.size();i++){
            TreeNode *t;
            int val = preorder[i];
            if(stk.top()->val != inorder[inorderIndex]){
                t = new TreeNode(val);
                stk.top()->left = t;
                stk.push(t);
            }
            else{
                while(!stk.empty()&&stk.top()->val == inorder[inorderIndex]){
                    t = stk.top();
                    stk.pop();
                    inorderIndex++;
                }
                t->right = new TreeNode(val);
                stk.push(t->right);
            }
        }
        return root;
    }
};
```

### 116. 填充每个节点的下一个右侧节点指针

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

1.层序遍历
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/
O(n)  O(n)
class Solution {
public:
    Node* connect(Node* root) {
        if(!root)
            return nullptr;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            int level = q.size();
            for(int i = 0;i<level;i++){
                Node* n = q.front();
                q.pop();
                if(i == level-1)
                    n->next = nullptr;
                else
                    n->next = q.front();
                if(n->left)
                    q.push(n->left);
                if(n->right)
                    q.push(n->right);
            } 
        }
        return root;
    }
};
```
### 230. 二叉搜索树中第K小的元素
给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）
思路：DFS
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode *> s;
        while(!s.empty()||root){
            while(root){
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            k--;
            if(k == 0){
                return root->val;
            }
            root = root->right;
        }
        return 0;
    }
};
```
### 671. 二叉树中第二小的节点
给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

思路：DFS
```cpp
//O（n） O(n)
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findSecondMinimumValue(TreeNode* root) {
        return min2nd(root, root -> val);
    }

    int min2nd(TreeNode* root, int val) {
        // 根节点为空
        if(!root)
            return -1;
        if(root->val>val)
            return root->val;
        int leftMin = min2nd(root->left,val);//寻找左边比根大的
        int rightMin = min2nd(root->right,val);//寻找右边比根大的
        if(leftMin>0&&rightMin>0)
            return min(leftMin,rightMin);
        return max(leftMin,rightMin); 
    }      
};

```