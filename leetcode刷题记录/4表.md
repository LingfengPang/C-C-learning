# 表
## 哈希表介绍
### 1.两数之和
给一个数值target，数组中存在两个数，这两个数的和是target,返回这两个数在数组中的下标
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int> m;//key表示值，value表示下标
        vector<int> res = {0,0};
        int size = nums.size();
        for(int i = 0;i<size;i++){
            int num = target - nums[i];
            if(m.count(num) != 0){
                res[0] = i;
                res[1] = m[num];
                break;
            }
            else
                m[nums[i]] = i; 
        }
        return res; 
    }
};
```
### 137. 只出现一次的数字 II
给定数组只有一个数是不重复的，其余都出现3次
1.哈希表计数
```cpp
//N N
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<int,int> m;
        for(auto n:nums){
            m[n]++;
        }
       map<int, int>::iterator it;  
       for(it = m.begin();it!=m.end();it++){
           if(it->second == 1)
                return it->first;
       }
    return 0;
    }
};
```

2.哈希表求和
数组和为s1;
set和乘上3为s2
不重复的数就是 a = (s2-s1)/2;
```cpp
N N
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> s;
        long sum1 = 0,sum2 = 0;//leetcode上用int溢出了

        for(auto n : nums){
            sum1 += n;
            if(s.find(n) == s.end()){
                s.insert(n);
                sum2 += n;
            }
        }

        return (sum2*3-sum1)/2;
    }
};
```



### 141. 环形链表
判断是否有环
思路，把遍历过的放到set里面
```cpp
// N N
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> s;
        for (int x: nums) {
            if (s.find(x) != s.end()) {
                return true;
            }
            s.insert(x);
        }
        return false;
    }
};

```
### 202. 快乐数
```
像这样最终能归1的数为快乐数
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```
思路：不是快乐数的数其平方和会陷入循环，所以我们建立哈希表来找找
```cpp
class Solution {
public:
    int sq_sum(int n){
        int num = n;
        int sum = 0;
        int bit;
        while(num>9){
            bit = num%10;
            sum += bit*bit;
            num /= 10;
        }
        sum += (num*num);
        return sum;
    }
    bool isHappy(int n) {
        if(n == 1)
            return true;
        set<int> num;
        int res = n;
        while(1)
        {
            res = sq_sum(res);
            if(res == 1)
                return true;
            else{
                if(num.find(res) != num.end())
                    return false;
                else
                    num.insert(res);
            }
        }
        return false;

    }
};
```




### 217.数组中是否存在重复元素
```cpp
// N N
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> s;
        for (int x: nums) {
            if (s.find(x) != s.end()) {
                return true;
            }
            s.insert(x);
        }
        return false;
    }
};

```
### 350. 两个数组的交集 II
```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) {
            return intersect(nums2, nums1);
        }
        vector<int>::iterator it = nums1.begin();
        unordered_map<int,int> m;
        vector<int> res;

        for(;it != nums1.end();it++){
            m[*it]++;
        }

        for(it = nums2.begin();it != nums2.end();it++){
            if(m.find(*it)!=m.end()){
                if(m[*it]>0){
                    res.push_back(*it);
                    m[*it]--;
                }    
            }
        }
        return res;
    }
};
```
