# 双指针法

## 快慢指针(E)
1.适合查有序列表重复项
2.适合有环的 
### 26.删除有序数组中的重复项目(E)
数组完成排序后，我们可以放置两个指针 ii 和 jj，其中 ii 是慢指针，而 jj 是快指针。只要 nums[i] = nums[j]nums[i]=nums[j]，我们就增加 jj 以跳过重复项。

```cpp
//升序序列里面删除重复项目
//时间On
//空间O（1）
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0)    return 0;
        int index = 0;
        for(int j = 1; j < nums.size(); ++j)
            if(nums[j] != nums[index])  nums[++index] = nums[j];
        return index + 1;
    }
};
```

### 141. 环形链表
判断链表是否有环
定义一个快指针和一个慢指针
快指针一次走两格
慢指针一次走一格
当两个指针相遇，如果不是链表尾部就，那么就是一个环了
```cpp
//N 1
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head)
            return false;
        ListNode *fast = head;
        ListNode *low = head;
        for(int i = 0;i<2;i++){
            if(fast->next)
                fast = fast->next;
        }
        while(fast != low){
            if(low->next)
                low = low->next;
            for(int i = 0;i<2;i++){
                if(fast->next && fast!=low)
                    fast = fast->next;
            }
        }
        return (low->next);
    }
};
```

### 142. 环形链表
找出环的起始点
![寻找重复数](image/142.PNG)
```cpp
//N 1
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast != nullptr) {
            slow = slow->next;
            if (fast->next == nullptr) {
                return nullptr;
            }
            fast = fast->next->next;
            if (fast == slow) {
                ListNode *ptr = head;
                while (ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

## 排序+双指针

### 350两个数组的交集II
```cpp
//mlogm+nlogn,min(m,n
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        vector<int>::iterator it1,it2;
        //排序
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        it1 = nums1.begin();
        it2 = nums2.begin();
        while(it1!=nums1.end()&&it2!=nums2.end()){
            if(*it1 == *it2){
                res.push_back(*it1);
                it1++;
                it2++;
            }
            else if(*it1 > *it2){
                it2++;
            }
            else
                it1++;
        }
        return res;
   }
};
```

## 快排思想

### 283.移动零
把数组中的0都移到末尾，而且在原数组操作

思路用快排的思想
不好讲，看代码理解
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0,right = 0;
        int size = nums.size();
        while(right < size){
            if(nums[right])
            {
                swap(nums[left],nums[right]);
                left++;
            }
            right++;
        }
    }
};
```